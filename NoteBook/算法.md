**地上有20枚硬币，一次只能捡一个或两个，两个人轮番减，你怎么能确保赢？如果地上是18枚硬币呢？21枚呢？**



**两个有序[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)合并为一个有序[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)？**

check: ZJ_25 双指针遍历

**输入数据如：3，32, 321 如何使他们拼接而成的值最小：321323**

排序 重写比价函数 if(AB<BA) then A < B;

**写一个检测5*5矩阵是否有连续的3个1，矩阵随机出0或1。**



**输出旋转数组，4*4的旋转数组类似于：**

**1  2   3  4**

**12 13 14 5**

**11 16 15 6**

**10 9  8  7**

check: JZ_29 边界控制

**输出一个数的数字的下一个排列，按递增序**

**1234 -> 1243**

**1432 -> 2134**

check: LC_31 首先查找逆向递增数列，再交换第一个大于左界的值

**手写算法 大数相加**

LC415 字符串相加？

**数组的数字合并成最小数 LC179**

check 排序 重写比价函数 if(AB<BA) then A < B;

**[算法题](https://www.nowcoder.com/jump/super-jump/word?word=算法题) LC93**

check:三重循环或者减枝回溯

**手写两个线程，交替打印奇偶数**

方法1：sychonized锁

**[一个有重复数组里的第 K 小的数](https://www.nowcoder.com/jump/super-jump/practice?questionId=44581)**

partration函数 O（logn）

**回文子串个数**



**[leetcode](https://www.nowcoder.com/jump/super-jump/word?word=leetcode)216（回溯）**



**公共字符：比如 label ， llabe ， wolley 输出 l，l，e（这个顺序不重要，只要个数对就行）**



**1.twoSum（说三种方法，实现一种方法）** 



 **2.合并[链表]()的变化版** 

 **数组num1{1，2，3}，数组num2{4，5，6}，把两个数组合并到num1上 num1{1,2,3,4,5,6}** 

 **（num1显然空间无线大）**



**找出给定数组的最长升序子数组并返回**

**[1,4,7,3,6,2]返回[1,4,7]**



**实现LRU/LFU算法**

